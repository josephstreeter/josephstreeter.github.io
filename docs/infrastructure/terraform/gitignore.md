---
title: "Terraform .gitignore Best Practices"
description: "Comprehensive guide to configuring .gitignore for Terraform projects to protect sensitive data and maintain clean version control"
author: "josephstreeter"
ms.date: "2025-01-18"
ms.topic: "reference"
keywords: ["Terraform", "Git", "Version Control", "Gitignore", "Security", "Best Practices", "State Files", "Secrets Management"]
---

When working with Terraform in a Git repository, a properly configured `.gitignore` file is essential for maintaining security and keeping your repository clean. This guide covers what files should be excluded from version control and why.

## Why .gitignore Matters for Terraform

Terraform projects generate several types of files that should **never** be committed to version control:

- **State files** containing sensitive infrastructure data
- **Variable files** with credentials, API keys, and secrets
- **Provider plugins** and cached dependencies
- **Lock files** from concurrent operations
- **Local overrides** for development customization

Accidentally committing these files can lead to:

- ❌ **Security breaches** - Exposed credentials and secrets
- ❌ **State conflicts** - Multiple team members modifying state
- ❌ **Repository bloat** - Large binary files in Git history
- ❌ **Configuration drift** - Environment-specific settings in shared code

---

## Complete .gitignore Template

```text
# Local .terraform directories
**/.terraform/*

# .tfstate files - NEVER commit these!
*.tfstate
*.tfstate.*

# Crash log files
crash.log
crash.*.log

# Exclude all .tfvars files, which are likely to contain sensitive data, such as
# passwords, private keys, and other secrets. These should not be part of version 
# control as they are data points which are potentially sensitive and subject 
# to change depending on the environment.
*.tfvars
*.tfvars.json

# Ignore override files as they are usually used to override resources locally and so
# are not checked in
override.tf
override.tf.json
*_override.tf
*_override.tf.json

# Include tfplan files to ignore the plan output of command: terraform plan -out=tfplan
# example: *tfplan*
*.tfplan
*.tfplan.*

# Ignore CLI configuration files
.terraformrc
terraform.rc

# Ignore transient lock info files created by terraform apply
.terraform.tfstate.lock.info

# Ignore lock file (optional - see note below)
# .terraform.lock.hcl

# Ignore backup files
*.backup
*.bak

# Ignore log files
*.log

# IDE and editor files
.vscode/
.idea/
*.swp
*.swo
*~
.DS_Store

# Include override files you do wish to add to version control using negated pattern
# !example_override.tf

# Include example tfvars files (sanitized versions without secrets)
# !terraform.tfvars.example
# !example.tfvars
```

---

## File-by-File Explanation

### State Files (Critical - Never Commit)

```text
*.tfstate
*.tfstate.*
```

**Why exclude:**

- Contains **complete infrastructure state** including all resource details
- May contain **sensitive data** like passwords, private keys, connection strings
- Contains **IP addresses, resource IDs**, and configuration details
- **Concurrent modifications** lead to state corruption

**Best practice:** Use remote state backend (Azure Storage, Terraform Cloud, S3)

### Variable Files (Security Risk)

```text
*.tfvars
*.tfvars.json
```

**Why exclude:**

- Typically contains **environment-specific values**
- Often includes **credentials, API keys, passwords**
- May contain **database connection strings**
- Different values for dev/staging/prod environments

**Best practice:**

- Use `.tfvars.example` files with dummy values (commit these)
- Store actual values in CI/CD secrets or key vaults
- Document required variables in README.md

**Example terraform.tfvars.example:**

```text
# terraform.tfvars.example
# Copy this file to terraform.tfvars and fill in actual values

resource_group_name = "rg-example-prod"
location            = "East US"
admin_password      = "CHANGEME"  # Use Azure Key Vault in production
```

### Terraform Directory

```text
**/.terraform/*
```

**Why exclude:**

- Contains **downloaded provider plugins** (large binary files)
- Contains **cached modules** from Terraform Registry or Git
- Automatically regenerated by `terraform init`
- Can be **hundreds of megabytes** in size

**Regeneration:** Run `terraform init` to recreate

### Plan Files

```text
*.tfplan
*.tfplan.*
```

**Why exclude:**

- Contains **complete plan output** with all changes
- May include **sensitive data** from state and variables
- **Binary format** not suitable for version control
- Becomes **stale** quickly as code changes

**Best practice:** Generate plans in CI/CD pipelines, don't commit

### Lock Files

```text
.terraform.lock.hcl
```

**Controversy:** Whether to commit this file depends on your workflow

**Commit if:**

- ✅ Ensuring **consistent provider versions** across team
- ✅ Working with **shared codebase** with multiple developers
- ✅ Need **reproducible builds** in CI/CD

**Exclude if:**

- ❌ Working with **multiple platforms** (Windows, Linux, macOS)
- ❌ Frequently updating providers
- ❌ Each environment needs **different provider versions**

**Best practice:** Usually **commit** for team projects

### Override Files

```text
override.tf
override.tf.json
*_override.tf
*_override.tf.json
```

**Why exclude:**

- Used for **local development customization**
- Override resources for **testing** without modifying main code
- **Personal preferences** shouldn't affect shared code

**Example use case:**

```text
# override.tf (not committed)
# Temporarily change instance size for local testing

resource "azurerm_virtual_machine" "example" {
  vm_size = "Standard_B1s"  # Cheaper for testing
}
```

### CLI Configuration

```text
.terraformrc
terraform.rc
```

**Why exclude:**

- Contains **personal CLI settings**
- May include **plugin cache locations**
- May contain **credentials** for private registries
- Different per developer

### Backup and Log Files

```text
*.backup
*.bak
*.log
crash.log
```

**Why exclude:**

- **Temporary files** created during operations
- **Log files** can contain sensitive information
- **Backup files** from text editors
- Not needed for version control

### IDE Files

```text
.vscode/
.idea/
*.swp
*.swo
*~
.DS_Store
```

**Why exclude:**

- **Editor-specific** settings and caches
- **Personal preferences** differ per developer
- Can create **merge conflicts**
- Not relevant to infrastructure code

---

## Advanced Patterns

### Include Specific Files

Sometimes you want to include certain files that would otherwise be ignored:

```text
# Ignore all .tfvars files
*.tfvars

# But include example files
!terraform.tfvars.example
!*.tfvars.example
```

### Module-Specific Ignores

For Terraform modules with examples:

```text
# Ignore example .terraform directories
examples/**/.terraform/*

# Ignore example state files
examples/**/*.tfstate
examples/**/*.tfstate.*
```

### Platform-Specific Patterns

```text
# Windows
Thumbs.db
ehthumbs.db
Desktop.ini

# macOS
.DS_Store
.AppleDouble
.LSOverride

# Linux
*~
.directory
```

---

## Security Best Practices

### 1. Never Commit Secrets

```text
# Bad - Committed secrets
admin_password = "MyPassword123!"  # DO NOT DO THIS

# Good - Reference from key vault
admin_password = data.azurerm_key_vault_secret.admin_pass.value
```

### 2. Use .tfvars.example Files

Provide templates without actual secrets:

```text
# terraform.tfvars.example
subscription_id = "00000000-0000-0000-0000-000000000000"
tenant_id       = "00000000-0000-0000-0000-000000000000"
admin_password  = "CHANGE_ME"
```

### 3. Scan for Exposed Secrets

Use tools to scan for accidentally committed secrets:

```bash
# Use git-secrets
git secrets --scan

# Use truffleHog
trufflehog git file://. --only-verified

# Use gitleaks
gitleaks detect --source . --verbose
```

### 4. Remove Committed Secrets

If you accidentally commit secrets:

```bash
# Option 1: Remove from recent commit
git reset HEAD~1
git add .gitignore
git commit -m "Add proper .gitignore"

# Option 2: Remove from history (destructive)
git filter-branch --force --index-filter \
  'git rm --cached --ignore-unmatch terraform.tfvars' \
  --prune-empty --tag-name-filter cat -- --all

# Option 3: Use BFG Repo-Cleaner
bfg --delete-files terraform.tfvars
git reflog expire --expire=now --all && git gc --prune=now --aggressive
```

**Important:** Immediately **rotate any exposed credentials**

---

## Team Collaboration

### Shared .gitignore

Place `.gitignore` at repository root:

```bash
terraform-project/
├── .gitignore              # Applies to entire repo
├── modules/
│   ├── networking/
│   └── compute/
└── environments/
    ├── dev/
    ├── staging/
    └── prod/
```

### Global .gitignore

Configure global Git ignore for personal files:

```bash
# Create global gitignore
git config --global core.excludesfile ~/.gitignore_global

# Add personal preferences
cat >> ~/.gitignore_global << EOF
# macOS
.DS_Store

# VS Code
.vscode/

# Terraform
.terraform/
EOF
```

### CI/CD Considerations

In CI/CD pipelines:

- ✅ **Do** commit `.terraform.lock.hcl` for consistency
- ✅ **Do** use example files for documentation
- ✅ **Don't** commit actual `.tfvars` with secrets
- ✅ **Don't** commit state files (use remote backend)

---

## Verification

### Check What's Tracked

```bash
# List all tracked files
git ls-files

# Check if sensitive files are tracked
git ls-files | grep -E '\.tfvars$|\.tfstate$'

# Check repository size
git count-objects -vH
```

### Test .gitignore

```bash
# Check if file would be ignored
git check-ignore -v terraform.tfvars

# See what would be added
git add --dry-run .

# Force add to verify exclusion
git add -f terraform.tfvars  # Should fail if properly ignored
```

---

## Common Mistakes

### ❌ Committing .tfvars Files

```bash
# Bad - accidentally committed
git add .
git commit -m "Update infrastructure"
```

**Fix:**

```bash
# Remove from staging
git reset terraform.tfvars

# Remove from history if committed
git rm --cached terraform.tfvars
git commit -m "Remove sensitive tfvars file"
```

### ❌ Committing State Files

```bash
# Bad - state file in repo
git add terraform.tfstate
```

**Fix:**

```bash
# Remove and use remote backend
git rm --cached *.tfstate
git commit -m "Remove state files"

# Configure remote backend
terraform {
  backend "azurerm" {
    resource_group_name  = "rg-terraform-state"
    storage_account_name = "sttfstate001"
    container_name       = "tfstate"
    key                  = "prod.terraform.tfstate"
  }
}
```

### ❌ Not Ignoring .terraform Directory

```bash
# Bad - huge directory in repo
git add .terraform/
```

**Fix:**

```bash
# Remove from repo
git rm -r --cached .terraform/
git commit -m "Remove .terraform directory"

# Add to .gitignore
echo ".terraform/" >> .gitignore
```

---

## Additional Resources

- [Terraform .gitignore Template](https://github.com/github/gitignore/blob/main/Terraform.gitignore)
- [Git Documentation - gitignore](https://git-scm.com/docs/gitignore)
- [Terraform Best Practices](https://www.terraform-best-practices.com/)
- [Terraform Security Best Practices](https://learn.hashicorp.com/tutorials/terraform/security-checklist)

---

## Quick Reference

### Essential Excludes (Minimum)

```text
.terraform/
*.tfstate
*.tfstate.*
*.tfvars
.terraform.lock.hcl  # Optional
```

### Recommended Full Template

Use the complete template provided at the top of this document for comprehensive coverage.

### Verification Checklist

- ✅ State files are excluded
- ✅ Variable files with secrets are excluded
- ✅ .terraform directory is excluded
- ✅ Example files (without secrets) are included
- ✅ Lock file handling is decided (include or exclude)
- ✅ IDE files are excluded
- ✅ No sensitive data in committed files
- ✅ Remote backend is configured for state

---

## Conclusion

A proper `.gitignore` file is your first line of defense against accidentally exposing sensitive infrastructure data. Always:

1. **Start with a comprehensive template** before writing any Terraform code
2. **Never commit secrets** - use examples or secure vaults instead
3. **Use remote state backends** - never store state in Git
4. **Review before committing** - check what files are being added
5. **Scan for secrets** - use automated tools to catch mistakes
6. **Educate your team** - ensure everyone understands what not to commit

Remember: Once something is committed to Git, it's extremely difficult to completely remove from history. Prevention is always better than remediation.
